#!/usr/bin/env python3
# -*- coding: utf-8 -*-

"""
üîê –ú–ò–®–£–†–ê - Financial Service
Production-ready —Å–µ—Ä–≤–∏—Å —Ñ–∏–Ω–∞–Ω—Å–æ–≤—ã—Ö –æ–ø–µ—Ä–∞—Ü–∏–π
–í–µ—Ä—Å–∏—è 1.0.0 - Bulletproof Financial Security
"""

import asyncio
import json
import uuid
import time
import hashlib
from datetime import datetime, timedelta
from typing import Dict, Optional, Any, Union
import logging
from settings import get_balance_override, get_initial_balance

logger = logging.getLogger(__name__)

class FinancialService:
    """
    üîê Production-ready —Å–µ—Ä–≤–∏—Å —Ñ–∏–Ω–∞–Ω—Å–æ–≤—ã—Ö –æ–ø–µ—Ä–∞—Ü–∏–π
    
    –û—Å–æ–±–µ–Ω–Ω–æ—Å—Ç–∏:
    - Optimistic locking –≤–º–µ—Å—Ç–æ FOR UPDATE
    - Connection pooling ready
    - Graceful degradation
    - Comprehensive logging
    - Backward compatibility
    """
    
    def __init__(self, db_instance):
        self.db = db_instance
        self.max_retries = 3
        self.retry_delay = 0.1  # 100ms
        self.lock_timeout = 30  # —Å–µ–∫—É–Ω–¥
        
        logger.info("üîê FinancialService –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω")
        
        # –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä—É–µ–º —Ç–∞–±–ª–∏—Ü—ã –µ—Å–ª–∏ –Ω—É–∂–Ω–æ
        self._init_financial_tables()
        
    def _init_financial_tables(self):
        """–°–æ–∑–¥–∞–Ω–∏–µ —Ç–∞–±–ª–∏—Ü transaction_log –∏ balance_locks"""
        try:
            conn = self.db.get_connection()
            cursor = conn.cursor()
            
            db_type = getattr(self.db, 'DB_CONFIG', {'type': 'sqlite'}).get('type', 'sqlite')
            
            if db_type == 'postgresql':
                # PostgreSQL —Å—Ö–µ–º–∞
                schema_sql = """
                -- –¢–∞–±–ª–∏—Ü–∞ –¥–ª—è –∞—É–¥–∏—Ç–∞ —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏–π
                CREATE TABLE IF NOT EXISTS transaction_log (
                    id BIGSERIAL PRIMARY KEY,
                    telegram_id BIGINT NOT NULL,
                    operation_type VARCHAR(50) NOT NULL,
                    transaction_type VARCHAR(20) NOT NULL,
                    amount INTEGER NOT NULL,
                    balance_before INTEGER NOT NULL,
                    balance_after INTEGER NOT NULL,
                    operation_id VARCHAR(255) UNIQUE NOT NULL,
                    correlation_id VARCHAR(255),
                    metadata JSONB DEFAULT '{}',
                    status VARCHAR(20) DEFAULT 'completed',
                    error_message TEXT,
                    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                    created_by VARCHAR(100) DEFAULT 'system'
                );

                -- –¢–∞–±–ª–∏—Ü–∞ –¥–ª—è optimistic locking
                CREATE TABLE IF NOT EXISTS balance_locks (
                    telegram_id BIGINT PRIMARY KEY,
                    version_number INTEGER DEFAULT 1,
                    last_updated TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                    locked_by VARCHAR(255),
                    lock_expires_at TIMESTAMP
                );

                -- –ò–Ω–¥–µ–∫—Å—ã
                CREATE INDEX IF NOT EXISTS idx_tlog_user_time 
                    ON transaction_log (telegram_id, created_at DESC);
                CREATE INDEX IF NOT EXISTS idx_tlog_operation_id 
                    ON transaction_log (operation_id);
                CREATE INDEX IF NOT EXISTS idx_tlog_correlation 
                    ON transaction_log (correlation_id);
                """
            else:
                # SQLite —Å—Ö–µ–º–∞
                schema_sql = """
                -- –¢–∞–±–ª–∏—Ü–∞ –¥–ª—è –∞—É–¥–∏—Ç–∞ —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏–π
                CREATE TABLE IF NOT EXISTS transaction_log (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    telegram_id INTEGER NOT NULL,
                    operation_type TEXT NOT NULL,
                    transaction_type TEXT NOT NULL,
                    amount INTEGER NOT NULL,
                    balance_before INTEGER NOT NULL,
                    balance_after INTEGER NOT NULL,
                    operation_id TEXT UNIQUE NOT NULL,
                    correlation_id TEXT,
                    metadata TEXT DEFAULT '{}',
                    status TEXT DEFAULT 'completed',
                    error_message TEXT,
                    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                    created_by TEXT DEFAULT 'system'
                );

                -- –¢–∞–±–ª–∏—Ü–∞ –¥–ª—è optimistic locking
                CREATE TABLE IF NOT EXISTS balance_locks (
                    telegram_id INTEGER PRIMARY KEY,
                    version_number INTEGER DEFAULT 1,
                    last_updated TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                    locked_by TEXT,
                    lock_expires_at TIMESTAMP
                );

                -- –ò–Ω–¥–µ–∫—Å—ã
                CREATE INDEX IF NOT EXISTS idx_tlog_user_time 
                    ON transaction_log (telegram_id, created_at DESC);
                CREATE INDEX IF NOT EXISTS idx_tlog_operation_id 
                    ON transaction_log (operation_id);
                CREATE INDEX IF NOT EXISTS idx_tlog_correlation 
                    ON transaction_log (correlation_id);
                """
            
            # –í—ã–ø–æ–ª–Ω—è–µ–º —Å–æ–∑–¥–∞–Ω–∏–µ —Ç–∞–±–ª–∏—Ü
            for statement in schema_sql.split(';'):
                statement = statement.strip()
                if statement:
                    cursor.execute(statement)
            
            conn.commit()
            conn.close()
            
            logger.info("‚úÖ –§–∏–Ω–∞–Ω—Å–æ–≤—ã–µ —Ç–∞–±–ª–∏—Ü—ã –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω—ã")
            
        except Exception as e:
            logger.error(f"‚ùå –û—à–∏–±–∫–∞ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏–∏ —Ñ–∏–Ω–∞–Ω—Å–æ–≤—ã—Ö —Ç–∞–±–ª–∏—Ü: {e}")
            if 'conn' in locals():
                conn.rollback()
                conn.close()
            raise
        
    def generate_operation_id(self, operation_type: str, user_id: int, 
                            extra_context: str = None) -> str:
        """–ì–µ–Ω–µ—Ä–∞—Ü–∏—è –¥–µ—Ç–µ—Ä–º–∏–Ω–∏—Ä–æ–≤–∞–Ω–Ω–æ–≥–æ operation_id –¥–ª—è idempotency"""
        
        # –î–ª—è –∫–æ–Ω—Å—É–ª—å—Ç–∞—Ü–∏–π - –∏—Å–ø–æ–ª—å–∑—É–µ–º –≤—Ä–µ–º–µ–Ω–Ω–æ–µ –æ–∫–Ω–æ (5 –º–∏–Ω—É—Ç)
        if operation_type in ['consultation_analysis', 'consultation_compare']:
            timestamp_window = int(time.time() // 300)  # 5-–º–∏–Ω—É—Ç–Ω—ã–µ –æ–∫–Ω–∞
            context = f"{user_id}_{operation_type}_{timestamp_window}"
            if extra_context:
                context += f"_{extra_context}"
            
            # –°–æ–∑–¥–∞–µ–º –∫–æ—Ä–æ—Ç–∫–∏–π —Ö–µ—à –¥–ª—è —á–∏—Ç–∞–µ–º–æ—Å—Ç–∏
            hash_obj = hashlib.md5(context.encode())
            return f"op_{hash_obj.hexdigest()[:8]}"
        
        # –î–ª—è –ø–ª–∞—Ç–µ–∂–µ–π - —É–Ω–∏–∫–∞–ª—å–Ω—ã–π ID
        return f"{operation_type}_{uuid.uuid4().hex[:8]}"
    
    def safe_balance_operation(self, telegram_id: int, amount_change: int,
                             operation_type: str, operation_id: str = None,
                             correlation_id: str = None,
                             metadata: Dict = None) -> Dict[str, Any]:
        """
        üîê –ë–ï–ó–û–ü–ê–°–ù–ê–Ø –æ–ø–µ—Ä–∞—Ü–∏—è —Å –±–∞–ª–∞–Ω—Å–æ–º (—Å–∏–Ω—Ö—Ä–æ–Ω–Ω–∞—è –≤–µ—Ä—Å–∏—è –¥–ª—è —Å–æ–≤–º–µ—Å—Ç–∏–º–æ—Å—Ç–∏)
        
        Returns:
            {
                'success': bool,
                'new_balance': int,
                'operation_id': str,
                'error': str (if failed),
                'retry_after': int (if rate limited)
            }
        """
        
        # –°–æ–∑–¥–∞–µ–º event loop –µ—Å–ª–∏ –µ–≥–æ –Ω–µ—Ç (–¥–ª—è —Å–∏–Ω—Ö—Ä–æ–Ω–Ω–æ–≥–æ –∫–æ–¥–∞)
        try:
            loop = asyncio.get_event_loop()
            if loop.is_running():
                # –ï—Å–ª–∏ loop —É–∂–µ –∑–∞–ø—É—â–µ–Ω, –∏—Å–ø–æ–ª—å–∑—É–µ–º create_task
                import concurrent.futures
                with concurrent.futures.ThreadPoolExecutor() as executor:
                    future = executor.submit(
                        asyncio.run,
                        self._async_safe_balance_operation(
                            telegram_id, amount_change, operation_type,
                            operation_id, correlation_id, metadata
                        )
                    )
                    return future.result()
            else:
                return loop.run_until_complete(
                    self._async_safe_balance_operation(
                        telegram_id, amount_change, operation_type,
                        operation_id, correlation_id, metadata
                    )
                )
        except RuntimeError:
            # –ù–µ—Ç –∞–∫—Ç–∏–≤–Ω–æ–≥–æ loop
            return asyncio.run(
                self._async_safe_balance_operation(
                    telegram_id, amount_change, operation_type,
                    operation_id, correlation_id, metadata
                )
            )
    
    async def _async_safe_balance_operation(self, telegram_id: int, amount_change: int,
                                          operation_type: str, operation_id: str = None,
                                          correlation_id: str = None,
                                          metadata: Dict = None) -> Dict[str, Any]:
        """–ê—Å–∏–Ω—Ö—Ä–æ–Ω–Ω–∞—è –≤–µ—Ä—Å–∏—è –±–µ–∑–æ–ø–∞—Å–Ω–æ–π –æ–ø–µ—Ä–∞—Ü–∏–∏ —Å –±–∞–ª–∞–Ω—Å–æ–º"""
        
        if not operation_id:
            operation_id = self.generate_operation_id(operation_type, telegram_id)
        
        if not correlation_id:
            correlation_id = str(uuid.uuid4())
        
        # 1. –ë–´–°–¢–†–ê–Ø –ü–†–û–í–ï–†–ö–ê IDEMPOTENCY (–±–µ–∑ –±–ª–æ–∫–∏—Ä–æ–≤–æ–∫)
        existing = self._check_operation_exists(operation_id)
        if existing:
            logger.info(f"Operation {operation_id} already exists (idempotent)")
            return {
                'success': True,
                'new_balance': existing['balance_after'],
                'operation_id': operation_id,
                'idempotent': True
            }
        
        # 2. OPTIMISTIC LOCKING —Å retry
        for attempt in range(self.max_retries):
            try:
                result = self._attempt_balance_operation(
                    telegram_id, amount_change, operation_type, 
                    operation_id, correlation_id, metadata
                )
                
                if result['success']:
                    return result
                    
                # –ï—Å–ª–∏ –Ω–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ —Å—Ä–µ–¥—Å—Ç–≤ - –Ω–µ —Ä–µ—Ç—Ä–∞–∏–º
                if result.get('error') == 'insufficient_balance':
                    return result
                    
            except Exception as e:
                logger.warning(f"Balance operation attempt {attempt + 1} failed: {e}")
                
                if attempt < self.max_retries - 1:
                    # Exponential backoff —Å jitter
                    delay = self.retry_delay * (2 ** attempt) + (time.time() % 0.1)
                    time.sleep(delay)
                else:
                    return {
                        'success': False,
                        'error': 'operation_failed',
                        'details': str(e)
                    }
        
        return {'success': False, 'error': 'max_retries_exceeded'}
    
    def _attempt_balance_operation(self, telegram_id: int, amount_change: int,
                                 operation_type: str, operation_id: str,
                                 correlation_id: str, metadata: Dict) -> Dict:
        """–û–¥–Ω–∞ –ø–æ–ø—ã—Ç–∫–∞ –æ–ø–µ—Ä–∞—Ü–∏–∏ —Å optimistic locking"""
        
        conn = None
        try:
            conn = self.db.get_connection()
            cursor = conn.cursor()
            
            # –ù–ê–ß–ò–ù–ê–ï–ú –ë–´–°–¢–†–£–Æ –¢–†–ê–ù–ó–ê–ö–¶–ò–Æ
            if self.db.DB_CONFIG['type'] == 'postgresql':
                # PostgreSQL: —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏–∏ –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏ –Ω–∞—á–∏–Ω–∞—é—Ç—Å—è, –Ω–∏—á–µ–≥–æ –Ω–µ –¥–µ–ª–∞–µ–º
                pass
            else:
                # SQLite: –∏—Å–ø–æ–ª—å–∑—É–µ–º conn.execute() –∫–∞–∫ —Ä–∞–Ω—å—à–µ
                conn.execute("BEGIN")
            
            # 1. –ü–æ–ª—É—á–∞–µ–º —Ç–µ–∫—É—â–∏–π –±–∞–ª–∞–Ω—Å –∏ –≤–µ—Ä—Å–∏—é (optimistic lock)
            user_data = self._get_user_with_version(conn, cursor, telegram_id)
            if not user_data:
                # –°–æ–∑–¥–∞–µ–º –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –µ—Å–ª–∏ –Ω–µ —Å—É—â–µ—Å—Ç–≤—É–µ—Ç
                user_data = self._create_user_if_not_exists(conn, cursor, telegram_id)
            
            current_balance = user_data['balance']
            current_version = user_data.get('version', 1)
            new_balance = current_balance + amount_change
            
            # 2. –ö–†–ò–¢–ò–ß–ï–°–ö–ê–Ø –ü–†–û–í–ï–†–ö–ê: –Ω–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ —Å—Ä–µ–¥—Å—Ç–≤
            if new_balance < 0:
                conn.rollback()
                return {
                    'success': False,
                    'error': 'insufficient_balance',
                    'required': abs(amount_change),
                    'available': current_balance
                }
            
            # 3. ATOMIC UPDATE —Å version check
            updated_rows = self._update_balance_with_version_check(
                conn, cursor, telegram_id, new_balance, current_version
            )
            
            if updated_rows == 0:
                # Version conflict - –¥—Ä—É–≥–∞—è —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏—è –æ–±–Ω–æ–≤–∏–ª–∞ –±–∞–ª–∞–Ω—Å
                conn.rollback()
                raise Exception("Version conflict - concurrent modification")
            
            # 4. –õ–û–ì–ò–†–£–ï–ú –¢–†–ê–ù–ó–ê–ö–¶–ò–Æ
            transaction_id = self._log_transaction(
                conn, cursor, telegram_id, operation_type, amount_change,
                current_balance, new_balance, operation_id,
                correlation_id, metadata
            )
            
            # 5. –ö–û–ú–ú–ò–¢–ò–ú
            conn.commit()
            
            logger.info(f"‚úÖ Balance operation success: {telegram_id} {current_balance}->{new_balance} ({operation_id})")
            
            return {
                'success': True,
                'new_balance': new_balance,
                'operation_id': operation_id,
                'transaction_id': transaction_id,
                'correlation_id': correlation_id
            }
            
        except Exception as e:
            if conn:
                conn.rollback()
            raise
        finally:
            if conn:
                conn.close()
    
    def _get_user_with_version(self, conn, cursor, telegram_id: int) -> Optional[Dict]:
        """–ü–æ–ª—É—á–µ–Ω–∏–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è —Å –≤–µ—Ä—Å–∏–µ–π –¥–ª—è optimistic locking"""
        
        if self.db.DB_CONFIG['type'] == 'postgresql':
            query = """
                SELECT u.balance, COALESCE(bl.version_number, 1) as version
                FROM users u
                LEFT JOIN balance_locks bl ON u.telegram_id = bl.telegram_id
                WHERE u.telegram_id = %s
            """
            cursor.execute(query, (telegram_id,))
        else:
            query = """
                SELECT u.balance, COALESCE(bl.version_number, 1) as version
                FROM users u
                LEFT JOIN balance_locks bl ON u.telegram_id = bl.telegram_id
                WHERE u.telegram_id = ?
            """
            cursor.execute(query, (telegram_id,))
        
        result = cursor.fetchone()
        if result:
            return {'balance': result[0], 'version': result[1]}
        return None
    
    def _update_balance_with_version_check(self, conn, cursor, telegram_id: int, 
                                         new_balance: int, expected_version: int) -> int:
        """–û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –±–∞–ª–∞–Ω—Å–∞ —Å –ø—Ä–æ–≤–µ—Ä–∫–æ–π –≤–µ—Ä—Å–∏–∏ (optimistic locking)"""
        
        new_version = expected_version + 1
        
        if self.db.DB_CONFIG['type'] == 'postgresql':
            # PostgreSQL
            update_user_query = """
                UPDATE users 
                SET balance = %s, updated_at = CURRENT_TIMESTAMP
                WHERE telegram_id = %s
            """
            cursor.execute(update_user_query, (new_balance, telegram_id))
            
            # –û–±–Ω–æ–≤–ª—è–µ–º –≤–µ—Ä—Å–∏—é —Å –ø—Ä–æ–≤–µ—Ä–∫–æ–π
            upsert_version_query = """
                INSERT INTO balance_locks (telegram_id, version_number, last_updated)
                VALUES (%s, %s, CURRENT_TIMESTAMP)
                ON CONFLICT (telegram_id) 
                DO UPDATE SET 
                    version_number = %s,
                    last_updated = CURRENT_TIMESTAMP
                WHERE balance_locks.version_number = %s
            """
            cursor.execute(upsert_version_query, 
                         (telegram_id, new_version, new_version, expected_version))
            return cursor.rowcount
            
        else:
            # SQLite
            # –û–±–Ω–æ–≤–ª—è–µ–º –±–∞–ª–∞–Ω—Å
            cursor.execute("""
                UPDATE users 
                SET balance = ?, updated_at = CURRENT_TIMESTAMP
                WHERE telegram_id = ?
            """, (new_balance, telegram_id))
            
            # –ü—Ä–æ–≤–µ—Ä—è–µ–º —Ç–µ–∫—É—â—É—é –≤–µ—Ä—Å–∏—é –∏ –æ–±–Ω–æ–≤–ª—è–µ–º –µ—Å–ª–∏ —Å–æ–≤–ø–∞–¥–∞–µ—Ç
            cursor.execute("""
                SELECT version_number FROM balance_locks WHERE telegram_id = ?
            """, (telegram_id,))
            
            current_version_row = cursor.fetchone()
            current_version = current_version_row[0] if current_version_row else 1
            
            if current_version != expected_version:
                return 0  # Version conflict
            
            # –û–±–Ω–æ–≤–ª—è–µ–º –≤–µ—Ä—Å–∏—é
            cursor.execute("""
                INSERT OR REPLACE INTO balance_locks 
                (telegram_id, version_number, last_updated)
                VALUES (?, ?, CURRENT_TIMESTAMP)
            """, (telegram_id, new_version))
            
            return 1
    
    def _log_transaction(self, conn, cursor, telegram_id: int, operation_type: str,
                       amount: int, balance_before: int, balance_after: int,
                       operation_id: str, correlation_id: str, 
                       metadata: Dict) -> int:
        """–õ–æ–≥–∏—Ä–æ–≤–∞–Ω–∏–µ —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏–∏"""
        
        # –ë–µ–∑–æ–ø–∞—Å–Ω–∞—è —Å–µ—Ä–∏–∞–ª–∏–∑–∞—Ü–∏—è metadata (–∑–∞—â–∏—Ç–∞ –æ—Ç JSON injection)
        safe_metadata = {}
        if metadata:
            for key, value in metadata.items():
                if isinstance(key, str) and len(key) < 100:
                    if isinstance(value, (str, int, float, bool)) and len(str(value)) < 1000:
                        safe_metadata[key] = value
        
        metadata_json = json.dumps(safe_metadata)
        transaction_type = 'credit' if amount > 0 else 'debit'
        
        if self.db.DB_CONFIG['type'] == 'postgresql':
            query = """
                INSERT INTO transaction_log 
                (telegram_id, operation_type, transaction_type, amount, 
                 balance_before, balance_after, operation_id, correlation_id, 
                 metadata, created_by)
                VALUES (%s, %s, %s, %s, %s, %s, %s, %s, %s, %s)
                RETURNING id
            """
            cursor.execute(query, (
                telegram_id, operation_type, transaction_type, amount,
                balance_before, balance_after, operation_id, correlation_id,
                metadata_json, 'financial_service'
            ))
            return cursor.fetchone()[0]
        else:
            cursor.execute("""
                INSERT INTO transaction_log 
                (telegram_id, operation_type, transaction_type, amount, balance_before, balance_after, 
                 operation_id, correlation_id, metadata, created_by)
                VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
            """, (telegram_id, operation_type, transaction_type, amount, balance_before, balance_after,
                  operation_id, correlation_id, metadata_json, 'financial_service'))
            return cursor.lastrowid
    
    def _check_operation_exists(self, operation_id: str) -> Optional[Dict]:
        """–ë—ã—Å—Ç—Ä–∞—è –ø—Ä–æ–≤–µ—Ä–∫–∞ —Å—É—â–µ—Å—Ç–≤–æ–≤–∞–Ω–∏—è –æ–ø–µ—Ä–∞—Ü–∏–∏"""
        try:
            conn = self.db.get_connection()
            cursor = conn.cursor()
            
            if self.db.DB_CONFIG['type'] == 'postgresql':
                query = "SELECT balance_after FROM transaction_log WHERE operation_id = %s LIMIT 1"
                cursor.execute(query, (operation_id,))
            else:
                cursor.execute("SELECT balance_after FROM transaction_log WHERE operation_id = ? LIMIT 1", 
                             (operation_id,))
            
            result = cursor.fetchone()
            conn.close()
            
            if result:
                return {'balance_after': result[0]}
            return None
            
        except Exception as e:
            logger.warning(f"Error checking operation existence: {e}")
            return None
    
    def _create_user_if_not_exists(self, conn, cursor, telegram_id: int) -> Dict:
        """–°–æ–∑–¥–∞–Ω–∏–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –µ—Å–ª–∏ –Ω–µ —Å—É—â–µ—Å—Ç–≤—É–µ—Ç"""
        
        initial_balance = get_initial_balance(telegram_id)
        
        if self.db.DB_CONFIG['type'] == 'postgresql':
            query = """
                INSERT INTO users (telegram_id, username, first_name, last_name, balance)
                VALUES (%s, 'webapp_user', 'WebApp', 'User', %s)
                ON CONFLICT (telegram_id) DO NOTHING
                RETURNING balance
            """
            cursor.execute(query, (telegram_id, initial_balance))
            result = cursor.fetchone()
            balance, version = result
            override_balance = get_balance_override(telegram_id)
            if override_balance is not None and balance < override_balance:
                try:
                    if self.db.DB_CONFIG['type'] == 'postgresql':
                        cursor.execute(
                            """
                                UPDATE users
                                SET balance = %s, updated_at = CURRENT_TIMESTAMP
                                WHERE telegram_id = %s
                            """,
                            (override_balance, telegram_id),
                        )
                    else:
                        cursor.execute(
                            """
                                UPDATE users
                                SET balance = ?, updated_at = CURRENT_TIMESTAMP
                                WHERE telegram_id = ?
                            """,
                            (override_balance, telegram_id),
                        )
                    balance = override_balance
                    logger.info(
                        "üîÑ –§–∏–Ω–∞–Ω—Å–æ–≤—ã–π —Å–µ—Ä–≤–∏—Å –ø–æ–≤—ã—Å–∏–ª –±–∞–ª–∞–Ω—Å %s –¥–æ —Ç–µ—Å—Ç–æ–≤–æ–≥–æ –∑–Ω–∞—á–µ–Ω–∏—è %s STcoin",
                        telegram_id,
                        override_balance,
                    )
                except Exception as override_error:
                    logger.warning(
                        "‚ö†Ô∏è –ù–µ —É–¥–∞–ª–æ—Å—å –ø–æ–≤—ã—Å–∏—Ç—å –±–∞–ª–∞–Ω—Å –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è %s –¥–æ —Ç–µ—Å—Ç–æ–≤–æ–≥–æ –∑–Ω–∞—á–µ–Ω–∏—è: %s",
                        telegram_id,
                        override_error,
                    )

            return {'balance': balance, 'version': version}
        else:
            cursor.execute("""
                INSERT OR IGNORE INTO users 
                (telegram_id, username, first_name, last_name, balance)
                VALUES (?, 'webapp_user', 'WebApp', 'User', ?)
            """, (telegram_id, initial_balance))
            
            # –ü–æ–ª—É—á–∞–µ–º –∞–∫—Ç—É–∞–ª—å–Ω—ã–π –±–∞–ª–∞–Ω—Å
            cursor.execute("SELECT balance FROM users WHERE telegram_id = ?", (telegram_id,))
            balance = cursor.fetchone()[0]
        
        override_balance = get_balance_override(telegram_id)
        if override_balance is not None and balance < override_balance:
            try:
                if self.db.DB_CONFIG['type'] == 'postgresql':
                    cursor.execute(
                        """
                            UPDATE users
                            SET balance = %s, updated_at = CURRENT_TIMESTAMP
                            WHERE telegram_id = %s
                        """,
                        (override_balance, telegram_id),
                    )
                else:
                    cursor.execute(
                        """
                            UPDATE users
                            SET balance = ?, updated_at = CURRENT_TIMESTAMP
                            WHERE telegram_id = ?
                        """,
                        (override_balance, telegram_id),
                    )
                balance = override_balance
                logger.info(
                    "üîÑ –§–∏–Ω–∞–Ω—Å–æ–≤—ã–π —Å–µ—Ä–≤–∏—Å –ø—Ä–∏–º–µ–Ω–∏–ª —Ç–µ—Å—Ç–æ–≤—ã–π –±–∞–ª–∞–Ω—Å %s STcoin –¥–ª—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è %s",
                    override_balance,
                    telegram_id,
                )
            except Exception as override_error:
                logger.warning(
                    "‚ö†Ô∏è –§–∏–Ω–∞–Ω—Å–æ–≤—ã–π —Å–µ—Ä–≤–∏—Å –Ω–µ —Å–º–æ–≥ –ø—Ä–∏–º–µ–Ω–∏—Ç—å —Ç–µ—Å—Ç–æ–≤—ã–π –±–∞–ª–∞–Ω—Å –¥–ª—è %s: %s",
                    telegram_id,
                    override_error,
                )

        return {'balance': balance, 'version': 1}
    
    def _get_existing_balance(self, cursor, telegram_id: int) -> int:
        """–ü–æ–ª—É—á–µ–Ω–∏–µ —Å—É—â–µ—Å—Ç–≤—É—é—â–µ–≥–æ –±–∞–ª–∞–Ω—Å–∞"""
        if self.db.DB_CONFIG['type'] == 'postgresql':
            cursor.execute("SELECT balance FROM users WHERE telegram_id = %s", (telegram_id,))
        else:
            cursor.execute("SELECT balance FROM users WHERE telegram_id = ?", (telegram_id,))
        
        result = cursor.fetchone()

        if result:
            balance = result[0]
            override_balance = get_balance_override(telegram_id)
            if override_balance is not None and balance < override_balance:
                return override_balance
            return balance

        return get_initial_balance(telegram_id)
    
    # BACKWARD COMPATIBILITY: –æ–±–µ—Ä—Ç–∫–∏ –¥–ª—è —Å—Ç–∞—Ä—ã—Ö –º–µ—Ç–æ–¥–æ–≤
    def update_user_balance(self, telegram_id: int, amount_change: int, 
                          operation_type: str = "legacy") -> int:
        """
        üîÑ BACKWARD COMPATIBLE wrapper –¥–ª—è —Å—É—â–µ—Å—Ç–≤—É—é—â–µ–≥–æ –∫–æ–¥–∞
        
        –í–ê–ñ–ù–û: –°–∏–Ω—Ö—Ä–æ–Ω–Ω–∞—è –≤–µ—Ä—Å–∏—è –¥–ª—è —Å–æ–≤–º–µ—Å—Ç–∏–º–æ—Å—Ç–∏ —Å bot.py
        """
        try:
            result = self.safe_balance_operation(
                telegram_id=telegram_id,
                amount_change=amount_change,
                operation_type=operation_type
            )
            
            if result['success']:
                return result['new_balance']
            else:
                logger.error(f"Balance operation failed: {result}")
                # –í–æ–∑–≤—Ä–∞—â–∞–µ–º —Ç–µ–∫—É—â–∏–π –±–∞–ª–∞–Ω—Å –ø—Ä–∏ –æ—à–∏–±–∫–µ
                return self.db.get_user_balance(telegram_id)
                
        except Exception as e:
            logger.error(f"Legacy balance operation failed: {e}")
            return self.db.get_user_balance(telegram_id)
    
    def get_transaction_history(self, telegram_id: int, limit: int = 20) -> list:
        """–ü–æ–ª—É—á–µ–Ω–∏–µ –∏—Å—Ç–æ—Ä–∏–∏ —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏–π –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è"""
        try:
            conn = self.db.get_connection()
            cursor = conn.cursor()
            
            if self.db.DB_CONFIG['type'] == 'postgresql':
                query = """
                    SELECT operation_type, transaction_type, amount, balance_before, 
                           balance_after, created_at, correlation_id
                    FROM transaction_log 
                    WHERE telegram_id = %s 
                    ORDER BY created_at DESC 
                    LIMIT %s
                """
                cursor.execute(query, (telegram_id, limit))
            else:
                cursor.execute("""
                    SELECT operation_type, transaction_type, amount, balance_before, 
                           balance_after, created_at, correlation_id
                    FROM transaction_log 
                    WHERE telegram_id = ? 
                    ORDER BY created_at DESC 
                    LIMIT ?
                """, (telegram_id, limit))
            
            transactions = []
            for row in cursor.fetchall():
                transactions.append({
                    'operation_type': row[0],
                    'transaction_type': row[1],
                    'amount': row[2],
                    'balance_before': row[3],
                    'balance_after': row[4],
                    'created_at': row[5],
                    'correlation_id': row[6]
                })
            
            conn.close()
            return transactions
            
        except Exception as e:
            logger.error(f"Error getting transaction history: {e}")
            return []
    
    def get_financial_stats(self) -> Dict[str, Any]:
        """–ü–æ–ª—É—á–µ–Ω–∏–µ —Ñ–∏–Ω–∞–Ω—Å–æ–≤–æ–π —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∏"""
        try:
            conn = self.db.get_connection()
            cursor = conn.cursor()
            
            # –û–±—â–∞—è —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞
            stats = {}
            
            # –ö–æ–ª–∏—á–µ—Å—Ç–≤–æ —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏–π –∑–∞ —Å–µ–≥–æ–¥–Ω—è
            if self.db.DB_CONFIG['type'] == 'postgresql':
                cursor.execute("""
                    SELECT COUNT(*) FROM transaction_log 
                    WHERE created_at >= CURRENT_DATE
                """)
            else:
                cursor.execute("""
                    SELECT COUNT(*) FROM transaction_log 
                    WHERE created_at >= date('now')
                """)
            
            stats['transactions_today'] = cursor.fetchone()[0]
            
            # –ö–æ–ª–∏—á–µ—Å—Ç–≤–æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π —Å –Ω—É–ª–µ–≤—ã–º –±–∞–ª–∞–Ω—Å–æ–º
            cursor.execute("SELECT COUNT(*) FROM users WHERE balance = 0")
            stats['zero_balance_users'] = cursor.fetchone()[0]
            
            # –û–±—â–µ–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π
            cursor.execute("SELECT COUNT(*) FROM users")
            stats['total_users'] = cursor.fetchone()[0]
            
            # –°—Ä–µ–¥–Ω–∏–π –±–∞–ª–∞–Ω—Å
            cursor.execute("SELECT AVG(balance) FROM users")
            avg_balance = cursor.fetchone()[0]
            stats['average_balance'] = round(avg_balance, 2) if avg_balance else 0
            
            conn.close()
            return stats
            
        except Exception as e:
            logger.error(f"Error getting financial stats: {e}")
            return {}